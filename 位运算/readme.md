
x ^ 0s = x      x & 0s = 0      x | 0s = x
x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
x ^ x = 0       x & x = x       x | x = x

* n&(n-1) 去除 n 的位级表示中最低的那一位。
* n&(-n) 得到 n 的位级表示中最低的那一位。
不用额外变量交换两个整数:

a = a ^ b;
b = a ^ b;
a = a ^ b;


位运算一直编程和面试中的一个必须准备的主题。 不过现在面试中关于位运算的出现得不多，主要原因还是位运算太考察技巧了，很多时候很难在短时间内想出来，所以作为面试的题目显得有点太花时间了。LeetCode中关于位运算的题目有以下几道：
Single Number
Single Number II
Divide Two Integers
Pow(x, n)

先来说说Single Number， 这应该LeetCode中唯一一道纯粹用位运算解决的题目。
题目本身要求是找出唯一一个在数组中出现一次的整数，而其他都会出现两次。
这里利用到了位运算中异或的性质，就是两个相同的数进行异或会得到0，并且任何一个数与0的异或还是原数。
利用上面的性质，只要把数组中的元素一一异或起来，因为出现两次的会互相抵消，最后会只剩下那个出现一次的整数，所以就搞定了。

对于Single Number II，上面的方法就没办法了，因为出现三次就不能利用异或的性质了，所以这个题目得使用另外的方法了。
算法是对每个位出现1的次数进行统计，因为其他元素都会出现三次，所以最终这些位上的1的个数会是3的倍数。
如果我们把统计结果的每一位进行取余3，剩下的结果就会剩下那个出现一次的元素。这个方法对于出现k次都是通用的，包括上面的Single Number也可以用这种方法，
不过没有纯位运算的方法高大上哈。

接下来看看位运算在Divide Two Integers和Pow(x, n)这道题中的应用，主要是利用任何一个整数可以表示成以2的幂为底的一组基的线性组合的性质，
即num=a_0*2^0+a_1*2^1+a_2*2^2+...+a_n*2^n。对于Divide Two Integers基于上面的性质以及左移一位相当于乘以2，
我们先让除数左移直到大于被除数之前得到一个最大的基。然后接下来我们每次尝试减去这个基，如果可以则结果增加加2^k，然后基继续右移迭代，直到基为0为止。
因为这个方法的迭代次数是按2的幂直到超过结果，所以时间复杂度可以达到O(logn)，也就是位的数量。而Pow(x, n)也是使用同样的方法，
把幂数n分解成2的幂数的基，然后进行依次平方然后求和。这个方法算是数值运算中的一个比较实用的方法，还是要熟练掌握。

这篇总结介绍了LeetCode中几个关于位运算的题目，虽然数量很少，不过思想上还是都挺有意义的，
如果面试中遇到能提出位运算的解法还是能加分不少，所以位运算在有些题目中还是一把关键的武器。